---
title: "02_training_model"
author: "Miguel √Ångel Armengol & Jay Chandra"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_notebook:
    code_folding: hide
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float: yes

knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = paste0(substr(inputFile,1,nchar(inputFile)-4)," ",Sys.Date(),'.html')) })
---


# Environment

```{r message=FALSE, warning=FALSE}
require(foreign)
require(ggplot2)
require(MASS)
require(Hmisc)
require(reshape2)
require(boot)
require(pROC)
library(mlbench)
library(MLmetrics)
library(plotly)
library(gbm)
library(xgboost)
library(oddsratio)
library(ggplot2)
library(survey)
library(table1)
library(sandwich)
library(dplyr)
#library(robustHD)
library(mgcv)
library(tidyverse)
library(caret)
center_scale <- function(x) {
    scale(x, scale = FALSE)
}
library(mgcViz)
```

# Plotting relationships

```{r}
ggplot(selected_df, aes(leaking_index,hosp_mortality) ) +
  stat_smooth() +
  ggtitle("GAM Model for Leaking Index and Hospital Mortality") +
  labs(y="Hospital Mortality", x = "Leaking Index")
```

```{r}
ggplot(selected_df, aes(leaking_index,delta_sofa) ) +
  stat_smooth() +
  ggtitle("GAM Model for Leaking Index and Hospital Mortality") +
  labs(y="Delta Sofa", x = "Leaking Index")
```

# Overall cohort

## GAM analysis

### Mortality
```{r}
library(mgcv)
# Build the model
model <- gam(hosp_mortality  ~
                         + s(leaking_index)
                         + age_fixed + gender + apache_iv + final_charlson_score
                         ,data=selected_df)
# Make predictions
predictions <- model %>% predict(selected_df)
# Model performance
data.frame(
  RMSE = RMSE(predictions, selected_df$hosp_mortality),
  R2 = R2(predictions, selected_df$hosp_mortality)
)
summary(model)
ggplot(selected_df, aes(leaking_index, hosp_mortality) ) +
  stat_smooth(method = gam, formula = y ~ s(x)) +
  ggtitle("GAM Model for Leaking Index and Hospital Mortality") +
  labs(y="Hospital Mortality", x = "Leaking Index")

b <- getViz(model)
plot( sm(b, 1) )
```

### Odds ratio

```{r}
# Quartiles
model <- gam(hosp_mortality  ~
                         + q_leaking_index
                         + age_fixed + gender + apache_iv + final_charlson_score,
                          family=binomial()
                         ,data=selected_df)

OR_table<-as.data.frame(round(exp(cbind(OR=coef(model), confint.default(model))),2))
options(scipen=999) # disable scientific notation
OR_table

# Continuous Variable
model <- gam(hosp_mortality  ~
                         + leaking_index
                         + age_fixed + gender + apache_iv + final_charlson_score,
                          family=binomial()
                         ,data=selected_df)

OR_table<-as.data.frame(round(exp(cbind(OR=coef(model), confint.default(model))),2))
options(scipen=999) # disable scientific notation
OR_table
```

### Delta Sofa
```{r}
library(mgcv)
# Build the model
model <- gam(delta_sofa  ~
                         + s(leaking_index)
                         + age_fixed + gender + apache_iv + final_charlson_score
                         ,data=selected_df)
# Make predictions
predictions <- model %>% predict(selected_df)
# Model performance
data.frame(
  RMSE = RMSE(predictions, selected_df$delta_sofa),
  R2 = R2(predictions, selected_df$delta_sofa)
)
summary(model)
ggplot(selected_df, aes(leaking_index, delta_sofa) ) +
  stat_smooth(method = gam, formula = y ~ s(x)) +
  ggtitle("GAM Model for Leaking Index and Delta_Sofa") +
  labs(y="Delta_Sofa", x = "Leaking Index")

b <- getViz(model)
plot( sm(b, 1) )
```
# Cohort with Fluid Balance at 72hrs and alive past 72hrs
## GAM Analysis
### Fluid Balance 72hrs
```{r}
library(mgcv)
# Build the model
model <- gam(fluid_balance_72  ~
                         s(leaking_index) + age_fixed + gender + fluid_balance
                         ,data=selected_df_fluid)
# Make predictions
predictions <- model %>% predict(selected_df_fluid)
# Model performance
data.frame(
  RMSE = RMSE(predictions, selected_df_fluid$fluid_balance_72),
  R2 = R2(predictions, selected_df_fluid$fluid_balance_72)
)
summary(model)
ggplot(selected_df_fluid, aes(leaking_index, fluid_balance_72) ) +
  stat_smooth(method = gam, formula = y ~ s(x)) +
  ggtitle("GAM Model for Leaking Index and Fluid Balance") +
  labs(y="Fluid Balance 72hrs", x = "Leaking Index")

b <- getViz(model)
plot( sm(b, 1) )
```

### Old GAM Fluid Balance 72hrs
```{r}
model_gam <- gam(fluid_balance_72  ~
                         + s(leaking_index)
                         + age_fixed + gender + fluid_balance + apache_iv + final_charlson_score
                         ,data=selected_df_fluid)
plotgam_model_gam<-mgcv::plot.gam(model_gam, n=200,select = 0)
plotgam_model_gam_exp<-as.data.frame(
  rbind(  
    cbind(
      plotgam_model_gam[[1]][["x"]] 
      ,plotgam_model_gam[[1]][["fit"]] + coef(model_gam)[1]
      ,plotgam_model_gam[[1]][["se"]] 
      
    )
  
  ))
plotgam_model_gam_exp[,c(1:3)] <- apply(plotgam_model_gam_exp[,c(1:3)], 2, function(x) as.numeric(as.character(x)))
colnames(plotgam_model_gam_exp)[1]<-'vli'
colnames(plotgam_model_gam_exp)[2]<-'fit'
colnames(plotgam_model_gam_exp)[3]<-'se.fit'
plotgam_model_gam_exp$lci<- plotgam_model_gam_exp$fit - 2 * plotgam_model_gam_exp$se.fit
plotgam_model_gam_exp$uci<- plotgam_model_gam_exp$fit + 2 * plotgam_model_gam_exp$se.fit
ggplot(data=plotgam_model_gam_exp, aes(vli, fit,colour='#039be5'))+
  geom_line()+
  geom_ribbon(data=plotgam_model_gam_exp,aes(x=vli,ymin=lci,ymax=uci,fill='#039be5'),alpha=0.3,inherit.aes=FALSE)+
  xlab('VLI')+
  ylab('mortality')+
  scale_color_manual(labels = c("Black", "White"), values = c("#1abc9c","#f1c40f"))+
  scale_fill_manual(labels = c("Black", "White"), values = c("#1abc9c","#f1c40f"))+
  labs(colour='Trend', fill='Trend') +
  theme_minimal()+theme(legend.position = 'none')  
```
# Causal inference

## Propensity Score Matching - logistic regression

We are not including totalFluid in the model since it is highly correlated with VLI.

```{r}
#first of all we create a copy of the dataset
vli_prop_score_dataset<-selected_df

# Fit a propensity score model: logistic regression
# outcome is the treatment here.
ps_model <- glm( highest_q_leaking_index ~ 
                  apache_iv
                + age_fixed
                + gender
                + final_charlson_score
                , family=binomial()
                , data=vli_prop_score_dataset)

summary(ps_model)

OR_table<-as.data.frame(round(exp(cbind(OR=coef(ps_model), confint.default(ps_model))),2))
options(scipen=999) # disable scientific notation
OR_table

# Value of propensity score for each patient

pscore<-ps_model$fitted.values

treatment_pscore<-cbind(vli_prop_score_dataset%>%dplyr::select(highest_q_leaking_index),pscore)

ggplot(treatment_pscore, aes(x=pscore, fill = highest_q_leaking_index)) + 
  geom_histogram(alpha = 0.5,position="identity")+scale_fill_manual(name="Treatment: Prob of Highest Q of VLI",values=c("#1abc9c","#f1c40f")                                                                ,labels=c("Q1","Q4"))+theme_minimal()+ggtitle('Distribution of propensity score')
```


## Inverse probability weighting

```{r}
# create weight
hr_prop_score_dataset<-vli_prop_score_dataset%>%mutate(
  weight=if_else(highest_q_leaking_index==1 # TODO: what is the control group? People in q1,q2,q3
                 ,1/(pscore)
                 ,1/(1-pscore))
)

hr_prop_score_dataset$weight<-as.numeric(as.character(hr_prop_score_dataset$weight))

ggplot(hr_prop_score_dataset, aes(x = weight, fill = highest_q_leaking_index)) +
   geom_density(alpha = 0.5, colour = "grey50") +
   geom_rug() +
   scale_x_log10(breaks = c(1, 5, 10, 20, 40)) +   ggtitle("Distribution of inverse probability weights")+ scale_fill_manual(name="Treatment: Highest Quartile of VLI",values=c("#1abc9c","#f1c40f")
                                                                                                                            # ,labels=c("Q1","Q4")
                                                                                                                             )+theme_minimal()

# apply weights to data
weighted_data<-svydesign(ids = ~ patientunitstayid, data = hr_prop_score_dataset, weights = ~weight )

# weighted table 1

#weighedtable<- svyCreateTableOne( vars= c("age", "gender","final_charlson_score","predictedHospitalMortality"), strata = "highest_q_leaking_index", data = weighted_data, test = F)

# weighted table 1 wih standarized mean differences (SMD)
#as.data.frame(print(weighedtable,smd=T))
# Ignore SD and sample sizes, ONLY SMD is reliable

```

In tableone: Ignore SD and sample sizes, ONLY SMD is reliable


## Marginal structural modeling

### Hospital Mortality prediction

#### Relative risk with CI

```{r warning=FALSE}
# Obtaining causal relative risk. Weighed GLM

glm_model_rr<-glm(
  hosp_mortality ~ 
  as.factor(highest_q_leaking_index)  # treatment is the only exposure now
, weights = weight  
, family = binomial(link = log) # we are using the log link since we are interested in the relative risk
, data= hr_prop_score_dataset
)

# summary of the glm_model_rr final model
# beta Inverse probability weighting
betaiptw<-coef(glm_model_rr)

# to properly account for weighting, we are going to use asymptotic (sandwich) variance

SE<-sqrt(diag(vcovHC(glm_model_rr,type = "HC0"))) # getting the standard error.

# we get point estimate and CI for relative risk

beta_causal_relative_risk<-exp(betaiptw[2]) # we need to exponientiate since we logged before
lCI<-exp(betaiptw[2]-1.96*SE[2])
uCI<-exp(betaiptw[2]+1.96*SE[2])

beta_final<-as.data.frame(cbind(beta_causal_relative_risk, lCI, uCI
                    ))

rownames(beta_final)<-''

beta_final
```

#### Risk difference with CI

```{r warning=FALSE}
# Obtaining Obtaining risk difference with CI

glm_model_diff<-glm(
 hosp_mortality ~ 
  as.factor(highest_q_leaking_index) # treatment is the only exposure now
, weights = weight  
, family = binomial(link = 'identity') # we are using the identity link since we are interested in risk difference
, data= hr_prop_score_dataset
)

# summary of the glm_model_diff final model
# beta Inverse probability weighting
betaiptw<-coef(glm_model_diff)

# to properly account for weighting, we are going to use asymptotic (sandwich) variance

SE<-sqrt(diag(vcovHC(glm_model_diff,type = "HC0"))) # getting the standard error.

# we get point estimate and CI for relative risk

beta_risk_diference<-exp(betaiptw[2]) # we need to exponientiate since we logged before
lCI<-exp(betaiptw[2]-1.96*SE[2])
uCI<-exp(betaiptw[2]+1.96*SE[2])

beta_final<-as.data.frame(cbind(beta_risk_diference, lCI, uCI
                    ))

rownames(beta_final)<-''

beta_final
```


### Q Delta Sofa prediction

#### Relative risk with CI

```{r warning=FALSE}
# Obtaining causal relative risk. Weighed GLM

glm_model_rr<-glm(
  delta_sofa ~ 
  as.factor(highest_q_leaking_index)  # treatment is the only exposure now
, weights = weight  
, family = poisson(link = log) # we are using the log link since we are interested in the relative risk
, data= hr_prop_score_dataset
)

# summary of the glm_model_rr final model
# beta Inverse probability weighting
betaiptw<-coef(glm_model_rr)

# to properly account for weighting, we are going to use asymptotic (sandwich) variance

SE<-sqrt(diag(vcovHC(glm_model_rr,type = "HC0"))) # getting the standard error.

# we get point estimate and CI for relative risk

beta_causal_relative_risk<-exp(betaiptw[2]) # we need to exponientiate since we logged before
lCI<-exp(betaiptw[2]-1.96*SE[2])
uCI<-exp(betaiptw[2]+1.96*SE[2])

beta_final<-as.data.frame(cbind(beta_causal_relative_risk, lCI, uCI
                    ))

rownames(beta_final)<-''

beta_final
```

#### Risk difference with CI

```{r warning=FALSE}
# Obtaining Obtaining risk difference with CI

glm_model_diff<-glm(
  delta_sofa ~ 
  as.factor(highest_q_leaking_index) # treatment is the only exposure now
, weights = weight  
, family = poisson(link = 'identity') # we are using the identity link since we are interested in risk difference
, data= hr_prop_score_dataset
)

# summary of the glm_model_diff final model
# beta Inverse probability weighting
betaiptw<-coef(glm_model_diff)

# to properly account for weighting, we are going to use asymptotic (sandwich) variance

SE<-sqrt(diag(vcovHC(glm_model_diff,type = "HC0"))) # getting the standard error.

# we get point estimate and CI for relative risk

beta_risk_diference<-exp(betaiptw[2]) # we need to exponientiate since we logged before
lCI<-exp(betaiptw[2]-1.96*SE[2])
uCI<-exp(betaiptw[2]+1.96*SE[2])

beta_final<-as.data.frame(cbind(beta_risk_diference, lCI, uCI
                    ))

rownames(beta_final)<-''

beta_final
```

